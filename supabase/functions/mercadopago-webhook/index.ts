
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  console.log('üì¢ Webhook MercadoPago recebido')
  
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
    
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Vari√°veis de ambiente n√£o configuradas')
    }
    
    const supabase = createClient(supabaseUrl, supabaseKey)

    const webhookData = await req.json()
    
    console.log('üì• Dados do webhook:', {
      action: webhookData.action,
      type: webhookData.type,
      dataId: webhookData.data?.id,
      topic: webhookData.topic
    })

    // Verificar se √© uma notifica√ß√£o de pagamento
    if (webhookData.type === 'payment' || webhookData.topic === 'payment') {
      const paymentId = webhookData.data?.id
      
      if (!paymentId) {
        console.log('‚ö†Ô∏è Webhook sem payment ID')
        return new Response('OK', { status: 200, headers: corsHeaders })
      }

      console.log('üí≥ Processando pagamento:', paymentId)

      // Buscar gateway para obter access token
      const { data: gateway } = await supabase
        .from('gateways')
        .select('credentials, environment')
        .eq('type', 'mercado_pago')
        .eq('is_active', true)
        .order('created_at', { ascending: false })
        .limit(1)
        .single()

      if (!gateway) {
        console.error('‚ùå Nenhum gateway MercadoPago ativo encontrado')
        return new Response('Gateway n√£o encontrado', { status: 400, headers: corsHeaders })
      }

      const credentials = gateway.credentials as any
      const environment = gateway.environment || 'sandbox'
      
      const accessToken = environment === 'production' 
        ? credentials.accessTokenProd 
        : credentials.accessTokenSandbox || credentials.accessToken

      if (!accessToken) {
        console.error('‚ùå Access token n√£o encontrado')
        return new Response('Credenciais n√£o configuradas', { status: 400, headers: corsHeaders })
      }

      // Consultar detalhes do pagamento na API do MercadoPago
      console.log('üîç Consultando pagamento na API...')
      
      const paymentResponse = await fetch(`https://api.mercadopago.com/v1/payments/${paymentId}`, {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        }
      })

      if (!paymentResponse.ok) {
        console.error('‚ùå Erro ao consultar pagamento:', paymentResponse.status)
        return new Response('Erro ao consultar pagamento', { status: 400, headers: corsHeaders })
      }

      const paymentDetails = await paymentResponse.json()
      
      console.log('üìä Detalhes do pagamento:', {
        id: paymentDetails.id,
        status: paymentDetails.status,
        externalReference: paymentDetails.external_reference,
        amount: paymentDetails.transaction_amount
      })

      // Atualizar status da venda no banco
      const { data: venda, error: vendaError } = await supabase
        .from('vendas')
        .select('id, status')
        .eq('payment_id', paymentId.toString())
        .maybeSingle()

      if (!venda) {
        // Tentar buscar por external_reference
        const { data: vendaByRef } = await supabase
          .from('vendas')
          .select('id, status')
          .eq('external_reference', paymentDetails.external_reference)
          .maybeSingle()
        
        if (vendaByRef) {
          console.log('üìù Venda encontrada por external_reference')
          
          // Atualizar com payment_id
          await supabase
            .from('vendas')
            .update({ payment_id: paymentId.toString() })
            .eq('id', vendaByRef.id)
        } else {
          console.log('‚ö†Ô∏è Venda n√£o encontrada para payment_id:', paymentId)
          return new Response('OK', { status: 200, headers: corsHeaders })
        }
      }

      // Determinar novo status baseado no status do MercadoPago
      let novoStatus = 'pendente'
      
      switch (paymentDetails.status) {
        case 'approved':
          novoStatus = 'paga'
          break
        case 'rejected':
        case 'cancelled':
          novoStatus = 'cancelada'
          break
        case 'pending':
        case 'in_process':
          novoStatus = 'pendente'
          break
        case 'refunded':
          novoStatus = 'cancelada'
          break
        default:
          console.log('‚ö†Ô∏è Status desconhecido:', paymentDetails.status)
          novoStatus = 'pendente'
      }

      // Atualizar status da venda
      const vendaId = venda?.id || vendaByRef?.id
      
      if (vendaId) {
        const { error: updateError } = await supabase
          .from('vendas')
          .update({ 
            status: novoStatus,
            payment_id: paymentId.toString()
          })
          .eq('id', vendaId)

        if (updateError) {
          console.error('‚ùå Erro ao atualizar venda:', updateError)
        } else {
          console.log('‚úÖ Status da venda atualizado:', {
            vendaId,
            novoStatus,
            paymentStatus: paymentDetails.status
          })
        }
      }
    }

    return new Response('OK', { status: 200, headers: corsHeaders })

  } catch (error) {
    console.error('‚ùå Erro no webhook:', error)
    return new Response('Erro interno', { status: 500, headers: corsHeaders })
  }
})
