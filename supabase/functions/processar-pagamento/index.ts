
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface PaymentRequest {
  checkoutId?: string
  gatewayId?: string
  token?: string
  customerData: {
    nome: string
    email: string
    telefone: string
    cpf: string
  }
  items: Array<{
    id: string
    title: string
    quantity: number
    unit_price: number
  }>
  totalAmount: number
  paymentMethod: 'credit_card' | 'pix'
  installments?: number
  environment?: 'sandbox' | 'production'
  externalReference?: string
  // Adicionar suporte para credenciais diretas
  directCredentials?: {
    publicKey: string
    accessToken: string
  }
}

serve(async (req) => {
  console.log('üöÄ Edge Function processar-pagamento iniciada')
  console.log('üìÖ Timestamp:', new Date().toISOString())
  
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    console.log('‚úÖ Respondendo a preflight request')
    return new Response(null, { headers: corsHeaders })
  }

  try {
    console.log('üîß Inicializando cliente Supabase...')
    const supabaseUrl = Deno.env.get('SUPABASE_URL')
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
    
    console.log('üîç Vari√°veis de ambiente:', {
      hasSupabaseUrl: !!supabaseUrl,
      hasSupabaseKey: !!supabaseKey,
      supabaseUrlPreview: supabaseUrl ? supabaseUrl.substring(0, 30) + '...' : 'MISSING'
    })
    
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Vari√°veis de ambiente do Supabase n√£o configuradas')
    }
    
    const supabase = createClient(supabaseUrl, supabaseKey)
    console.log('‚úÖ Cliente Supabase inicializado')

    console.log('üì• Lendo dados da requisi√ß√£o...')
    let paymentData: PaymentRequest
    try {
      const rawBody = await req.text()
      console.log('üìÑ Raw body length:', rawBody.length)
      paymentData = JSON.parse(rawBody)
      
      console.log('‚úÖ Dados recebidos:', JSON.stringify({
        paymentMethod: paymentData.paymentMethod,
        totalAmount: paymentData.totalAmount,
        gatewayId: paymentData.gatewayId,
        customerName: paymentData.customerData?.nome,
        environment: paymentData.environment,
        hasToken: !!paymentData.token,
        itemsCount: paymentData.items?.length || 0
      }, null, 2))
    } catch (parseError) {
      console.error('‚ùå Erro ao fazer parse dos dados:', parseError)
      throw new Error('Dados inv√°lidos na requisi√ß√£o: ' + parseError.message)
    }

      console.log('üîç Validando dados da requisi√ß√£o...')
      
      // Validar dados do cliente de forma mais robusta
      if (!paymentData.customerData) {
        console.error('‚ùå Dados do cliente ausentes')
        throw new Error('Dados do cliente s√£o obrigat√≥rios')
      }
      
      // Verificar nome - mais flex√≠vel
      if (!paymentData.customerData.nome?.trim()) {
        console.error('‚ùå Nome do cliente n√£o fornecido:', paymentData.customerData)
        throw new Error('Nome completo √© obrigat√≥rio')
      }
      
      // Verificar email - mais flex√≠vel  
      if (!paymentData.customerData.email?.trim()) {
        console.error('‚ùå Email do cliente n√£o fornecido:', paymentData.customerData)
        throw new Error('Email √© obrigat√≥rio')
      }
      
      // Validar email b√°sico - mais flex√≠vel
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      if (!emailRegex.test(paymentData.customerData.email)) {
        console.error('‚ùå Email inv√°lido:', paymentData.customerData.email)
        throw new Error('Email deve ter um formato v√°lido')
      }
      
      // Validar CPF mais flex√≠vel - tornar opcional para PIX
      if (paymentData.customerData.cpf && paymentData.customerData.cpf.replace(/\D/g, '').length > 0) {
        const cpfClean = paymentData.customerData.cpf.replace(/\D/g, '')
        if (cpfClean.length !== 11) {
          console.error('‚ùå CPF inv√°lido:', paymentData.customerData.cpf)
          throw new Error('CPF deve ter 11 d√≠gitos')
        }
      }

      if (!paymentData.items || paymentData.items.length === 0) {
        console.error('‚ùå Nenhum item no pedido')
        throw new Error('Pelo menos um item √© obrigat√≥rio')
      }

      if (!paymentData.totalAmount || paymentData.totalAmount <= 0) {
        console.error('‚ùå Valor total inv√°lido:', paymentData.totalAmount)
        throw new Error('Valor total deve ser maior que zero')
      }

      if (!['credit_card', 'pix'].includes(paymentData.paymentMethod)) {
        console.error('‚ùå M√©todo de pagamento inv√°lido:', paymentData.paymentMethod)
        throw new Error('M√©todo de pagamento deve ser "credit_card" ou "pix"')
      }

      console.log('‚úÖ Valida√ß√µes b√°sicas passaram')
      console.log('üîÑ Processando pagamento:', paymentData.paymentMethod, 'R$', paymentData.totalAmount)

      // Buscar credenciais do gateway
      let gatewayCredentials = null
      let environment = paymentData.environment || 'sandbox'
      
        // NOVO: Priorizar credenciais diretas se fornecidas
      if (paymentData.directCredentials) {
        console.log('üîë Usando credenciais diretas fornecidas na requisi√ß√£o')
        console.log('üîç Credenciais diretas:', {
          hasPublicKey: !!paymentData.directCredentials.publicKey,
          hasAccessToken: !!paymentData.directCredentials.accessToken,
          publicKeyPreview: paymentData.directCredentials.publicKey?.substring(0, 20) + '...',
          accessTokenPreview: paymentData.directCredentials.accessToken?.substring(0, 20) + '...'
        })
        
        // Detectar ambiente com valida√ß√£o rigorosa de credenciais
        const isProductionCreds = paymentData.directCredentials.accessToken?.startsWith('APP_USR-') && 
                                 paymentData.directCredentials.publicKey?.startsWith('APP_USR-');
        const isSandboxCreds = paymentData.directCredentials.accessToken?.startsWith('TEST-') && 
                              paymentData.directCredentials.publicKey?.startsWith('TEST-');
        
        let detectedEnvironment;
        if (isProductionCreds) {
          detectedEnvironment = 'production';
        } else if (isSandboxCreds) {
          detectedEnvironment = 'sandbox';
        } else {
          console.error('‚ùå Credenciais inv√°lidas:', {
            accessTokenPrefix: paymentData.directCredentials.accessToken?.substring(0, 8),
            publicKeyPrefix: paymentData.directCredentials.publicKey?.substring(0, 8)
          });
          throw new Error('Credenciais do MercadoPago inv√°lidas ou inconsistentes');
        }
        
        console.log('üåç Ambiente detectado das credenciais diretas:', detectedEnvironment);
        environment = detectedEnvironment; // Sempre usar ambiente detectado automaticamente
        
        // Configurar credenciais baseadas no ambiente detectado
        if (detectedEnvironment === 'production') {
          gatewayCredentials = {
            accessTokenProd: paymentData.directCredentials.accessToken,
            publicKeyProd: paymentData.directCredentials.publicKey,
            accessTokenSandbox: '', // Limpar para evitar confus√£o
            publicKeySandbox: ''
          }
        } else {
          gatewayCredentials = {
            accessTokenSandbox: paymentData.directCredentials.accessToken,
            publicKeySandbox: paymentData.directCredentials.publicKey,
            accessTokenProd: '', // Limpar para evitar confus√£o
            publicKeyProd: ''
          }
        }
        
        console.log('‚úÖ Ambiente final definido:', environment);
        // Pular busca no banco e ir direto para o processamento
      } else {
      
      if (paymentData.gatewayId) {
        console.log('üîç Buscando credenciais do gateway no banco...', paymentData.gatewayId)
        let { data: gateway, error: gatewayError } = await supabase
          .from('gateways')
          .select('credentials, type, environment, name, is_active')
          .eq('id', paymentData.gatewayId)
          .single()
        
        if (gatewayError) {
          console.error('‚ùå Erro ao buscar gateway:', gatewayError)
          
          // Tentar buscar qualquer gateway MercadoPago ativo como fallback
          console.log('üîÑ Tentando fallback para gateway MercadoPago...')
          const { data: fallbackGateway, error: fallbackError } = await supabase
            .from('gateways')
            .select('credentials, type, environment, name, is_active')
            .eq('type', 'mercado_pago')
            .eq('is_active', true)
            .order('created_at', { ascending: false })
            .limit(1)
            .single()
          
          if (fallbackError || !fallbackGateway) {
            console.error('‚ùå Nenhum gateway MercadoPago ativo encontrado')
            throw new Error('Gateway de pagamento n√£o configurado')
          }
          
          console.log('‚úÖ Gateway fallback encontrado:', fallbackGateway.name)
          gateway = fallbackGateway
        }
        
        if (!gateway) {
          console.error('‚ùå Gateway n√£o encontrado:', paymentData.gatewayId)
          throw new Error('Gateway n√£o encontrado')
        }

        if (!gateway.is_active) {
          console.error('‚ùå Gateway inativo:', paymentData.gatewayId)
          throw new Error('Gateway est√° inativo')
        }
        
        if (gateway.type !== 'mercado_pago') {
          console.error('‚ùå Gateway n√£o √© Mercado Pago:', gateway.type)
          throw new Error('Gateway n√£o √© do tipo Mercado Pago')
        }
        
        gatewayCredentials = gateway.credentials
        environment = gateway.environment || environment
        
        console.log('‚úÖ Gateway encontrado:', {
          name: gateway.name,
          type: gateway.type,
          environment: environment,
          hasCredentials: !!gatewayCredentials,
          credentialKeys: gatewayCredentials ? Object.keys(gatewayCredentials) : []
        })
      
    } else {
      console.log('‚ö†Ô∏è Nenhum gateway espec√≠fico, buscando fallback ativo...')
      
      // Fallback: buscar qualquer gateway MercadoPago ativo
      const { data: fallbackGateway, error: fallbackError } = await supabase
        .from('gateways')
        .select('credentials, type, environment, name, is_active')
        .eq('type', 'mercado_pago')
        .eq('is_active', true)
        .order('created_at', { ascending: false })
        .limit(1)
        .single()
      
      if (fallbackError || !fallbackGateway) {
        console.log('‚ö†Ô∏è Nenhum gateway ativo encontrado, usando credenciais do ambiente...')
        gatewayCredentials = {
          accessTokenSandbox: Deno.env.get('MP_ACCESS_TOKEN_SANDBOX') || 'TEST-3388903873791416-070505-d2bd52e12df128675573159519eb7aaf-337331937',
          publicKeySandbox: Deno.env.get('MP_PUBLIC_KEY_SANDBOX') || 'TEST-128ed321-c483-4220-b857-275935dd8498',
          accessTokenProd: Deno.env.get('MP_ACCESS_TOKEN_PROD'),
          publicKeyProd: Deno.env.get('MP_PUBLIC_KEY_PROD')
        }
        environment = 'sandbox' // Force sandbox when using default credentials
        console.log('üîß Usando credenciais padr√£o de sandbox para desenvolvimento')
      } else {
        console.log('‚úÖ Gateway fallback encontrado:', fallbackGateway.name)
        gatewayCredentials = fallbackGateway.credentials
        environment = fallbackGateway.environment || environment
      }
    }
    } // Fechar o bloco do else que foi aberto

    // Determinar access token baseado no ambiente
    let accessToken: string | undefined
    const isProduction = environment === 'production'
    
    if (isProduction) {
      accessToken = (gatewayCredentials as any).accessTokenProd || (gatewayCredentials as any).accessToken
    } else {
      accessToken = (gatewayCredentials as any).accessTokenSandbox || (gatewayCredentials as any).accessToken
    }

    console.log('üåç Ambiente determinado:', isProduction ? 'PRODU√á√ÉO' : 'SANDBOX')
    console.log('üîç Access token encontrado:', !!accessToken)

    if (!accessToken) {
      console.error('‚ùå Access token n√£o encontrado para ambiente:', environment)
      console.error('üîç Credenciais dispon√≠veis:', {
        hasProd: !!(gatewayCredentials as any).accessTokenProd,
        hasSandbox: !!(gatewayCredentials as any).accessTokenSandbox,
        hasLegacy: !!(gatewayCredentials as any).accessToken,
        environment
      })
      throw new Error(`Credenciais do MercadoPago n√£o configuradas para ambiente ${environment}`)
    }

    console.log('üîë Usando token:', accessToken.substring(0, 20) + '...')

    // Processar pagamento baseado no m√©todo
    let paymentResponse
    
    if (paymentData.paymentMethod === 'pix') {
      console.log('üü¢ Criando pagamento PIX...')
      paymentResponse = await createPixPayment(accessToken, paymentData, isProduction)
    } else {
      console.log('üí≥ Criando pagamento com cart√£o...')
      if (!paymentData.token) {
        console.error('‚ùå Token do cart√£o n√£o fornecido para pagamento com cart√£o')
        throw new Error('Token do cart√£o √© obrigat√≥rio para pagamento com cart√£o')
      }
      paymentResponse = await createCreditCardPayment(accessToken, paymentData, isProduction)
    }

    console.log('üíæ Salvando transa√ß√£o no banco de dados...')
    
    // Primeiro criar/buscar cliente
    let cliente: any
    try {
      console.log('üë§ Criando/buscando cliente...')
      
      // Buscar cliente existente por email
      const { data: clienteExistente, error: clienteSearchError } = await supabase
        .from('clientes')
        .select('id')
        .eq('email', paymentData.customerData.email)
        .maybeSingle()
      
      if (clienteSearchError) {
        console.error('‚ùå Erro ao buscar cliente:', clienteSearchError)
      }
      
      if (clienteExistente) {
        console.log('‚úÖ Cliente existente encontrado:', clienteExistente.id)
        cliente = clienteExistente
      } else {
        console.log('üë§ Criando novo cliente...')
        const { data: novoCliente, error: clienteError } = await supabase
          .from('clientes')
          .insert({
            nome: paymentData.customerData.nome,
            email: paymentData.customerData.email,
            cpf: paymentData.customerData.cpf || null
          })
          .select('id')
          .single()
        
        if (clienteError) {
          console.error('‚ùå Erro ao criar cliente:', clienteError)
          throw new Error('Erro ao criar cliente: ' + clienteError.message)
        }
        
        console.log('‚úÖ Cliente criado com ID:', novoCliente.id)
        cliente = novoCliente
      }
    } catch (clienteError) {
      console.error('‚ùå Erro cr√≠tico ao processar cliente:', clienteError)
      throw new Error('Erro ao processar dados do cliente')
    }
    
    // Agora criar a venda
    let venda: any
    try {
      console.log('üí∞ Criando venda...')
      
      const { data, error: vendaError } = await supabase
        .from('vendas')
        .insert({
          id_cliente: cliente.id,
          email_cliente: paymentData.customerData.email,
          metodo_pagamento: paymentData.paymentMethod === 'pix' ? 'pix' : 'cartao_credito',
          valor_total: paymentData.totalAmount,
          status: 'pendente',
          external_reference: paymentData.externalReference || paymentResponse?.id?.toString() || null,
          payment_id: paymentResponse?.id?.toString() || null
        })
        .select('id')
        .single()

      if (vendaError) {
        console.error('‚ùå Erro ao salvar venda:', vendaError)
        throw new Error('Erro ao salvar venda: ' + vendaError.message)
      }
      
      venda = data
      console.log('‚úÖ Venda criada com ID:', venda.id)
      
    } catch (insertError) {
      console.error('‚ùå Erro cr√≠tico ao inserir venda:', insertError)
      throw new Error('Erro ao processar venda: ' + insertError.message)
    }
    
    // Criar itens da venda
    try {
      console.log('üì¶ Criando itens da venda...')
      
      const itensVenda = paymentData.items.map(item => ({
        id_venda: venda.id,
        id_produto: item.id,
        preco_unitario: item.unit_price,
        quantidade: item.quantity || 1
      }))
      
      const { error: itensError } = await supabase
        .from('itens_da_venda')
        .insert(itensVenda)
      
      if (itensError) {
        console.error('‚ö†Ô∏è Erro ao salvar itens da venda:', itensError)
        // N√£o quebrar o fluxo se der erro nos itens
      } else {
        console.log('‚úÖ Itens da venda salvos:', itensVenda.length)
      }
      
    } catch (itensError) {
      console.error('‚ö†Ô∏è Erro ao processar itens da venda:', itensError)
      // N√£o quebrar o fluxo se der erro nos itens
    }

    // Preparar resposta
    const response = {
      success: true,
      payment: paymentResponse,
      orderId: venda?.id || 'unknown',
      redirectUrl: paymentData.paymentMethod === 'pix' 
        ? `/pix/${venda?.id || 'temp'}` 
        : `/obrigado/${venda?.id || 'temp'}`,
      environment,
      webhook: {
        url: 'https://xpljmuqtkdlvsbbsrmjg.supabase.co/functions/v1/mercadopago-webhook',
        configured: true
      }
    }

    // Para PIX, incluir dados espec√≠ficos
    if (paymentData.paymentMethod === 'pix') {
      response.pixData = paymentResponse;
      response.orderData = {
        totalAmount: paymentData.totalAmount,
        items: paymentData.items
      };
    }

    console.log('üöÄ Retornando resposta de sucesso')
    console.log('üìä Resumo:', {
      success: response.success,
      orderId: response.orderId,
      paymentMethod: paymentData.paymentMethod,
      redirectUrl: response.redirectUrl,
      environment: response.environment
    })

    return new Response(
      JSON.stringify(response),
      { 
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json' 
        } 
      }
    )

  } catch (error) {
    console.error('‚ùå ERRO CR√çTICO na Edge Function:', error)
    console.error('‚ùå Stack trace:', error.stack)
    console.error('‚ùå Timestamp do erro:', new Date().toISOString())
    
    const errorMessage = error instanceof Error ? error.message : 'Erro interno do servidor'
    console.error('‚ùå Mensagem do erro:', errorMessage)
    
    const errorResponse = {
      success: false,
      error: errorMessage,
      timestamp: new Date().toISOString(),
      details: 'Verifique os logs da Edge Function para mais detalhes',
      // Adicionar mais contexto para debug
      errorType: error.constructor.name,
      stack: error.stack?.split('\n').slice(0, 5) // Primeiras 5 linhas do stack
    }
    
    console.error('üì§ Retornando erro detalhado:', JSON.stringify(errorResponse, null, 2))
    
    return new Response(
      JSON.stringify(errorResponse),
      { 
        status: 400, // Usar status 400 para erros de valida√ß√£o/dados
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json' 
        } 
      }
    )
  }
})

async function createPixPayment(accessToken: string, paymentData: PaymentRequest, isProduction: boolean) {
  const baseUrl = 'https://api.mercadopago.com'
  console.log('üîó URL base da API:', baseUrl)

  const paymentBody: any = {
    transaction_amount: paymentData.totalAmount,
    description: `Compra - ${paymentData.items.map(i => i.title).join(', ')}`,
    payment_method_id: 'pix',
    external_reference: paymentData.externalReference || `checkout_${Date.now()}`,
    notification_url: 'https://xpljmuqtkdlvsbbsrmjg.supabase.co/functions/v1/mercadopago-webhook',
    payer: {
      email: paymentData.customerData.email,
      first_name: paymentData.customerData.nome.split(' ')[0],
      last_name: paymentData.customerData.nome.split(' ').slice(1).join(' ') || ''
    }
  }

  // Adicionar CPF apenas se fornecido
  if (paymentData.customerData.cpf && paymentData.customerData.cpf.replace(/\D/g, '').length === 11) {
    paymentBody.payer.identification = {
      type: 'CPF', 
      number: paymentData.customerData.cpf.replace(/\D/g, '')
    }
  }

  console.log('üì§ Enviando dados PIX para MercadoPago:', JSON.stringify(paymentBody, null, 2))

  const response = await fetch(`${baseUrl}/v1/payments`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
      'X-Idempotency-Key': crypto.randomUUID()
    },
    body: JSON.stringify(paymentBody)
  })

  const result = await response.json()
  console.log('üì• Resposta da API MercadoPago PIX:', JSON.stringify(result, null, 2))
  
  if (!response.ok) {
    console.error('‚ùå Erro MP PIX - Status:', response.status)
    console.error('‚ùå Erro MP PIX - Body:', result)
    throw new Error(result.message || `Erro HTTP ${response.status} ao criar pagamento PIX`)
  }

  console.log('‚úÖ PIX criado com sucesso - ID:', result.id, 'Status:', result.status)
  return result
}

async function createCreditCardPayment(accessToken: string, paymentData: PaymentRequest, isProduction: boolean) {
  const baseUrl = 'https://api.mercadopago.com'
  console.log('üîó URL base da API:', baseUrl)

  const paymentBody: any = {
    transaction_amount: paymentData.totalAmount,
    token: paymentData.token,
    description: `Compra - ${paymentData.items.map(i => i.title).join(', ')}`,
    installments: paymentData.installments || 1,
    payment_method_id: 'visa', // Will be determined by token
    external_reference: paymentData.externalReference || `checkout_${Date.now()}`,
    notification_url: 'https://xpljmuqtkdlvsbbsrmjg.supabase.co/functions/v1/mercadopago-webhook',
    payer: {
      email: paymentData.customerData.email
    }
  }

  // Adicionar CPF apenas se fornecido
  if (paymentData.customerData.cpf && paymentData.customerData.cpf.replace(/\D/g, '').length === 11) {
    paymentBody.payer.identification = {
      type: 'CPF',
      number: paymentData.customerData.cpf.replace(/\D/g, '')
    }
  }

  console.log('üì§ Enviando dados Cart√£o para MercadoPago:', JSON.stringify({
    ...paymentBody,
    token: paymentData.token?.substring(0, 20) + '...'
  }, null, 2))

  const response = await fetch(`${baseUrl}/v1/payments`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
      'X-Idempotency-Key': crypto.randomUUID()
    },
    body: JSON.stringify(paymentBody)
  })

  const result = await response.json()
  console.log('üì• Resposta da API MercadoPago Cart√£o:', JSON.stringify(result, null, 2))
  
  if (!response.ok) {
    console.error('‚ùå Erro MP Cart√£o - Status:', response.status) 
    console.error('‚ùå Erro MP Cart√£o - Body:', result)
    throw new Error(result.message || `Erro HTTP ${response.status} ao processar cart√£o`)
  }

  console.log('‚úÖ Cart√£o processado com sucesso - ID:', result.id, 'Status:', result.status)
  return result
}
