
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';

interface Gateway {
  id: string;
  name: string;
  type: string;
  credentials: {
    publicKeyProd?: string;
    accessTokenProd?: string;
    publicKeySandbox?: string;
    accessTokenSandbox?: string;
    publicKey?: string;
    accessToken?: string;
  };
  environment: string;
  is_active: boolean;
}

export const usePublicGateway = (gatewayId: string | null) => {
  const [gateway, setGateway] = useState<Gateway | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const maxRetries = 3;

  const fetchGateway = useCallback(async (attempt = 1) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log(`üîç usePublicGateway: Tentativa ${attempt}/${maxRetries} - Buscando gateway:`, gatewayId);
      console.log('üîç Supabase client dispon√≠vel:', !!supabase);
      
      let gateway = null;
      
      // Estrat√©gia 1: Buscar gateway espec√≠fico se ID fornecido
      if (gatewayId) {
        console.log('üéØ Buscando gateway espec√≠fico:', gatewayId);
        const { data: specificGateway, error: specificError } = await supabase
          .from('gateways')
          .select('*')
          .eq('id', gatewayId)
          .eq('is_active', true)
          .single();

        console.log('üîç Resultado da consulta espec√≠fica:', { data: specificGateway, error: specificError });

        if (!specificError && specificGateway) {
          console.log('‚úÖ Gateway espec√≠fico encontrado:', specificGateway.name);
          gateway = specificGateway;
        } else {
          console.log('‚ö†Ô∏è Gateway espec√≠fico n√£o encontrado, tentando fallback...');
          console.log('‚ö†Ô∏è Erro da consulta espec√≠fica:', specificError);
        }
      }

      // Estrat√©gia 2: Fallback para qualquer gateway MercadoPago ativo
      if (!gateway) {
        console.log('üîÑ Buscando qualquer gateway MercadoPago ativo...');
        const { data: fallbackGateway, error: fallbackError } = await supabase
          .from('gateways')
          .select('*')
          .eq('type', 'mercado_pago')
          .eq('is_active', true)
          .order('created_at', { ascending: false })
          .limit(1)
          .single();

        console.log('üîç Resultado da consulta fallback:', { data: fallbackGateway, error: fallbackError });

        if (!fallbackError && fallbackGateway) {
          console.log('‚úÖ Gateway fallback encontrado:', fallbackGateway.name);
          gateway = fallbackGateway;
        } else {
          console.log('‚ùå Nenhum gateway MercadoPago ativo encontrado');
          console.log('‚ùå Erro da consulta fallback:', fallbackError);
        }
      }

      // Estrat√©gia 3: Se ainda n√£o encontrou, buscar qualquer gateway MercadoPago (mesmo inativo)
      if (!gateway) {
        console.log('üîÑ √öltima tentativa: buscando qualquer gateway MercadoPago...');
        const { data: anyGateway, error: anyError } = await supabase
          .from('gateways')
          .select('*')
          .eq('type', 'mercado_pago')
          .order('created_at', { ascending: false })
          .limit(1)
          .single();

        if (!anyError && anyGateway) {
          console.log('‚ö†Ô∏è Gateway encontrado mas pode estar inativo:', anyGateway.name, 'Ativo:', anyGateway.is_active);
          gateway = anyGateway;
        }
      }

      if (!gateway) {
        throw new Error('Nenhum gateway MercadoPago configurado no sistema');
      }

      // Validar credenciais do gateway
      const credentials = gateway.credentials as any;
      const hasValidCredentials = (
        (credentials?.publicKeySandbox && credentials?.accessTokenSandbox) ||
        (credentials?.publicKeyProd && credentials?.accessTokenProd) ||
        (credentials?.publicKey && credentials?.accessToken)
      );

      if (!hasValidCredentials) {
        console.error('‚ùå Gateway encontrado mas sem credenciais v√°lidas:', {
          id: gateway.id,
          name: gateway.name,
          credentialKeys: credentials ? Object.keys(credentials) : []
        });
        throw new Error('Gateway encontrado mas credenciais n√£o configuradas');
      }

      console.log('‚úÖ Gateway validado com sucesso:', {
        id: gateway.id,
        name: gateway.name,
        type: gateway.type,
        environment: gateway.environment,
        isActive: gateway.is_active,
        hasCredentials: hasValidCredentials
      });

      // Credentials para uso p√∫blico (incluindo accessToken para pagamentos)
      const publicCredentials = {
        publicKey: credentials?.publicKeySandbox || credentials?.publicKeyProd || credentials?.publicKey || '',
        publicKeySandbox: credentials?.publicKeySandbox || '',
        publicKeyProd: credentials?.publicKeyProd || '',
        accessToken: credentials?.accessTokenSandbox || credentials?.accessTokenProd || credentials?.accessToken || '',
        accessTokenSandbox: credentials?.accessTokenSandbox || '',
        accessTokenProd: credentials?.accessTokenProd || '',
        environment: gateway.environment || 'sandbox'
      };

      setGateway({
        id: gateway.id,
        name: gateway.name,
        type: gateway.type,
        credentials: publicCredentials,
        environment: gateway.environment || 'sandbox',
        is_active: gateway.is_active
      });

      setRetryCount(0); // Reset retry count on success

    } catch (err) {
      console.error(`‚ùå usePublicGateway: Erro na tentativa ${attempt}:`, err);
      
      // Implementar retry logic
      if (attempt < maxRetries) {
        const delay = attempt * 1000; // Delay progressivo
        console.log(`‚è≥ Aguardando ${delay}ms antes da pr√≥xima tentativa...`);
        setRetryCount(attempt);
        
        setTimeout(() => {
          fetchGateway(attempt + 1);
        }, delay);
        return;
      }
      
      setError(err instanceof Error ? err.message : 'Erro ao carregar gateway de pagamento');
      setGateway(null);
    } finally {
      setLoading(false);
    }
  }, [gatewayId, maxRetries]);

  useEffect(() => {
    if (gatewayId !== undefined) { // Allow null but not undefined
      console.log('üîÑ usePublicGateway: Iniciando busca por gateway:', gatewayId);
      fetchGateway();
    }
  }, [gatewayId, fetchGateway]);

  // Fun√ß√£o para tentar novamente manualmente
  const retry = useCallback(() => {
    console.log('üîÑ usePublicGateway: Retry manual solicitado');
    setRetryCount(0);
    fetchGateway();
  }, [fetchGateway]);

  return { 
    gateway, 
    loading, 
    error, 
    retry,
    retryCount
  };
};
