
import { useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { useMercadoPagoContext } from '@/context/MercadoPagoContext';
import { useOrderContext } from '@/context/OrderContext';
import { useProductContext } from '@/context/ProductContext';
import { supabase } from '@/integrations/supabase/client';
import { CustomerFormData, CreditCardData } from '@/types/checkout';
import { CheckoutConfig } from '@/api/mockDatabase';
import { OrderCalculationResult } from '@/core/checkoutEngine';

interface UseMercadoPagoPaymentProps {
  checkout: CheckoutConfig | null;
  orderCalculation: OrderCalculationResult | null;
}

export const useMercadoPagoPayment = ({
  checkout,
  orderCalculation
}: UseMercadoPagoPaymentProps) => {
  const navigate = useNavigate();
  const { addOrder } = useOrderContext();
  const { getProductById } = useProductContext();
  const { 
    isInitialized, 
    accessToken, 
    environment,
    mpInstance,
    error: mpError,
    initializeMercadoPago,
    retryInitialization,
    loading: mpLoading
  } = useMercadoPagoContext();

  const createCardToken = useCallback(async (creditCardData: CreditCardData) => {
    console.log('üí≥ Criando token do cart√£o...');
    console.log('üîç Estado do MP:', { isInitialized, hasAccessToken: !!accessToken, environment });

    // Garantir que o SDK est√° inicializado
    if (!isInitialized || !mpInstance || mpLoading) {
      console.log('üîÑ SDK n√£o inicializado, tentando inicializar...');
      try {
        await initializeMercadoPago();
      } catch (error) {
        console.error('‚ùå Falha na inicializa√ß√£o:', error);
        throw new Error('Falha ao inicializar sistema de pagamento');
      }
    }

    if (!mpInstance) {
      console.error('‚ùå Inst√¢ncia do MercadoPago n√£o est√° dispon√≠vel');
      throw new Error('Sistema de pagamento n√£o carregado. Tente novamente.');
    }

    console.log('‚úÖ Usando inst√¢ncia MercadoPago:', typeof mpInstance);
    const mp = mpInstance;
    
    const dadosCartao = {
      cardNumber: creditCardData.numero.replace(/\s/g, ''),
      cardholderName: creditCardData.nome,
      cardExpirationMonth: creditCardData.validade.split('/')[0],
      cardExpirationYear: `20${creditCardData.validade.split('/')[1]}`,
      securityCode: creditCardData.cvv,
      identificationType: 'CPF',
      identificationNumber: creditCardData.cpf.replace(/\D/g, '')
    };

    console.log('üì§ Dados do cart√£o preparados:', {
      cardNumber: dadosCartao.cardNumber.replace(/\d/g, '*'),
      cardholderName: dadosCartao.cardholderName,
      expirationMonth: dadosCartao.cardExpirationMonth,
      expirationYear: dadosCartao.cardExpirationYear
    });

    try {
      const cardToken = await mp.createCardToken(dadosCartao);
      
      if (cardToken.error) {
        console.error('‚ùå Token retornou erro:', cardToken.error);
        throw new Error('Dados do cart√£o inv√°lidos. Verifique as informa√ß√µes e tente novamente.');
      }

      if (!cardToken.id) {
        console.error('‚ùå Token criado mas sem ID:', cardToken);
        throw new Error('Falha na valida√ß√£o do cart√£o. Tente novamente.');
      }

      console.log('‚úÖ Token do cart√£o criado com sucesso:', cardToken.id);
      return cardToken;
    } catch (error) {
      console.error('‚ùå Erro ao criar token:', error);
      throw new Error('Erro ao validar dados do cart√£o. Verifique as informa√ß√µes.');
    }
  }, [isInitialized, initializeMercadoPago, accessToken, environment, mpLoading, mpInstance]);

  const processPixPayment = useCallback(async (
    formData: CustomerFormData,
    selectedOrderBumps: string[]
  ) => {
    if (!checkout || !orderCalculation) {
      throw new Error('Dados do checkout n√£o carregados');
    }

    console.log('üü¢ [PIX DEBUG] Iniciando processamento PIX...', {
      checkoutId: checkout.id,
      gatewayId: checkout.gatewayId,
      environment,
      customerData: {
        nome: formData.nome ? 'PRESENTE' : 'AUSENTE',
        email: formData.email ? 'PRESENTE' : 'AUSENTE',
        telefone: formData.telefone ? 'PRESENTE' : 'AUSENTE',
        cpf: formData.cpf ? 'PRESENTE' : 'AUSENTE'
      },
      totalAmount: orderCalculation.totalFinal,
      accessTokenPresent: !!accessToken,
      mpInitialized: isInitialized,
      mpLoading
    });

    // Garantir que o contexto est√° inicializado - mas ser mais flex√≠vel
    if (!isInitialized && !mpLoading) {
      console.log('üîÑ Contexto n√£o inicializado, tentando inicializar...');
      try {
        await initializeMercadoPago();
        // Aguardar um pouco ap√≥s inicializa√ß√£o
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.error('‚ùå Falha na inicializa√ß√£o do contexto:', error);
        // N√£o falhar aqui se tivermos credenciais diretas
        console.log('‚ö†Ô∏è Continuando sem inicializa√ß√£o devido a credenciais diretas...');
      }
    }

    // Verificar credenciais - ser mais flex√≠vel
    if (!accessToken) {
      console.warn('‚ö†Ô∏è Access token n√£o dispon√≠vel via contexto, verificando credenciais diretas...');
      
      // Buscar gateway manualmente se necess√°rio
      if (!checkout.gatewayId) {
        console.error('‚ùå Nem access token nem gateway ID dispon√≠vel');
        throw new Error('Sistema de pagamento n√£o configurado');
      }
      
      console.log('üì§ Continuando com credenciais diretas via Edge Function...');
    }

    // Obter dados dos produtos
    const mainProduct = getProductById(checkout.mainProductId);
    const orderBumps = selectedOrderBumps.map(id => getProductById(id)).filter(Boolean);

    if (!mainProduct) {
      throw new Error('Produto principal n√£o encontrado');
    }

    const items = [
      {
        id: checkout.mainProductId,
        title: mainProduct.name || 'Produto',
        quantity: 1,
        unit_price: mainProduct.price || 0
      },
      ...orderBumps.map(bump => ({
        id: bump.id,
        title: bump.name || 'Order Bump',
        quantity: 1,
        unit_price: bump.price || 0
      }))
    ];

    console.log('üì¶ Itens do pedido:', items);
    console.log('üí∞ Valor total:', orderCalculation.totalFinal);

    try {
      // Criar external_reference √∫nico para correlacionar com webhook
      const externalReference = `checkout_${checkout.id}_${Date.now()}`;
      
      // Dados que ser√£o enviados para a Edge Function
      const payloadData = {
        checkoutId: checkout.id,
        gatewayId: checkout.gatewayId || 'fallback',
        customerData: formData,
        items,
        totalAmount: orderCalculation.totalFinal,
        paymentMethod: 'pix',
        environment,
        externalReference,
        directCredentials: {
          publicKey: accessToken ? '' : '',
          accessToken: accessToken || ''
        }
      };

      console.log('üì§ [PIX DEBUG] Dados enviados para Edge Function:', {
        checkoutId: checkout.id,
        gatewayId: checkout.gatewayId || 'fallback', 
        totalAmount: orderCalculation.totalFinal,
        itemsCount: items.length,
        environment,
        hasAccessToken: !!accessToken,
        customerFields: Object.keys(formData).filter(key => formData[key as keyof CustomerFormData])
      });
      
      const response = await supabase.functions.invoke('processar-pagamento', {
        body: payloadData
      });

      console.log('üì• [PIX DEBUG] Resposta completa da Edge Function:', {
        hasError: !!response.error,
        hasData: !!response.data,
        errorDetails: response.error,
        dataKeys: response.data ? Object.keys(response.data) : [],
        status: response.data?.success ? 'SUCCESS' : 'FAILURE'
      });

      // Tratamento detalhado de erros
      if (response.error) {
        console.error('‚ùå [PIX DEBUG] Erro da Edge Function:', {
          message: response.error.message,
          details: response.error.details,
          hint: response.error.hint,
          code: response.error.code
        });
        
        // Mensagens de erro mais espec√≠ficas para o usu√°rio
        let userMessage = 'Erro ao processar PIX';
        
        if (response.error.message?.includes('credentials')) {
          userMessage = 'Credenciais do MercadoPago inv√°lidas. Verifique a configura√ß√£o.';
        } else if (response.error.message?.includes('gateway')) {
          userMessage = 'Gateway de pagamento n√£o configurado. Contate o suporte.';
        } else if (response.error.message?.includes('required')) {
          userMessage = 'Dados obrigat√≥rios faltando. Verifique o formul√°rio.';
        } else if (response.error.message?.includes('amount')) {
          userMessage = 'Valor do pagamento inv√°lido.';
        }
        
        throw new Error(userMessage);
      }

      if (response.data?.success) {
        console.log('‚úÖ [PIX DEBUG] PIX processado com sucesso, redirecionando...', {
          hasRedirectUrl: !!response.data.redirectUrl,
          hasPixData: !!response.data.pixData,
          hasOrderData: !!response.data.orderData
        });
        
        navigate(response.data.redirectUrl, {
          state: {
            pixData: response.data.pixData,
            orderData: response.data.orderData
          }
        });
        return true;
      } else {
        console.error('‚ùå [PIX DEBUG] Resposta de falha:', {
          responseData: response.data,
          errorMessage: response.data?.error
        });
        
        const errorMessage = response.data?.error || 'Falha no processamento do PIX';
        throw new Error(errorMessage);
      }
    } catch (error) {
      console.error('‚ùå [PIX DEBUG] Erro no processamento PIX:', {
        errorType: error instanceof Error ? error.constructor.name : typeof error,
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      
      // Re-throw com mensagem mais amig√°vel se necess√°rio
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('Erro inesperado no processamento do PIX');
      }
    }
  }, [checkout, orderCalculation, isInitialized, accessToken, environment, getProductById, navigate, initializeMercadoPago, mpLoading, mpInstance]);

  const processCreditCardPayment = useCallback(async (
    formData: CustomerFormData,
    creditCardData: CreditCardData,
    selectedOrderBumps: string[],
    selectedInstallments: number = 1
  ) => {
    if (!checkout || !orderCalculation) {
      throw new Error('Dados do checkout n√£o carregados');
    }

    console.log('üí≥ Iniciando processamento cart√£o...', {
      checkoutId: checkout.id,
      gatewayId: checkout.gatewayId,
      environment,
      installments: selectedInstallments
    });

    // Garantir que o contexto est√° inicializado
    if (!isInitialized || !mpInstance || mpLoading) {
      console.log('üîÑ Contexto n√£o inicializado, tentando inicializar...');
      try {
        await initializeMercadoPago();
      } catch (error) {
        console.error('‚ùå Falha na inicializa√ß√£o do contexto:', error);
        throw new Error('Sistema de pagamento n√£o inicializado');
      }
    }

    if (!accessToken) {
      console.error('‚ùå Access token n√£o dispon√≠vel');
      throw new Error('Credenciais do MercadoPago n√£o configuradas');
    }

    // Criar token do cart√£o
    console.log('üîÑ Criando token do cart√£o...');
    const cardToken = await createCardToken(creditCardData);

    // Obter dados dos produtos
    const mainProduct = getProductById(checkout.mainProductId);
    const orderBumps = selectedOrderBumps.map(id => getProductById(id)).filter(Boolean);

    if (!mainProduct) {
      throw new Error('Produto principal n√£o encontrado');
    }

    const items = [
      {
        id: checkout.mainProductId,
        title: mainProduct.name || 'Produto',
        quantity: 1,
        unit_price: mainProduct.price || 0
      },
      ...orderBumps.map(bump => ({
        id: bump.id,
        title: bump.name || 'Order Bump',
        quantity: 1,
        unit_price: bump.price || 0
      }))
    ];

    console.log('üì¶ Itens do pedido:', items);
    console.log('üí∞ Valor total:', orderCalculation.totalFinal);

    try {
      // Criar external_reference √∫nico para correlacionar com webhook
      const externalReference = `checkout_${checkout.id}_${Date.now()}`;
      
      const response = await supabase.functions.invoke('processar-pagamento', {
        body: {
          checkoutId: checkout.id,
          gatewayId: checkout.gatewayId || 'fallback',
          token: cardToken.id,
          customerData: formData,
          items,
          totalAmount: orderCalculation.totalFinal,
          paymentMethod: 'credit_card',
          installments: selectedInstallments,
          environment,
          externalReference,
          directCredentials: {
            publicKey: accessToken ? '' : '',
            accessToken: accessToken || ''
          }
        }
      });

      console.log('üì§ Dados enviados para Edge Function:', {
        checkoutId: checkout.id,
        gatewayId: checkout.gatewayId || 'fallback',
        totalAmount: orderCalculation.totalFinal,
        hasToken: !!cardToken.id,
        itemsCount: items.length
      });

      console.log('üì• Resposta da Edge Function:', response);

      if (response.error) {
        console.error('‚ùå Erro da Edge Function:', response.error);
        throw new Error(response.error.message || 'Erro no servidor de pagamento');
      }

      if (!response.data) {
        throw new Error('Resposta inv√°lida do servidor');
      }
      
      if (response.data.success) {
        console.log('‚úÖ Pagamento processado com sucesso!');
        navigate(response.data.redirectUrl);
        return true;
      } else {
        console.error('‚ùå Pagamento recusado:', response.data);
        throw new Error(response.data.error || 'Pagamento recusado pelo gateway');
      }
    } catch (error) {
      console.error('‚ùå Erro no processamento cart√£o:', error);
      throw error;
    }
  }, [checkout, orderCalculation, isInitialized, accessToken, environment, createCardToken, getProductById, navigate, initializeMercadoPago, mpLoading, mpInstance]);

  const isReady = isInitialized && !!accessToken && !!mpInstance && !mpLoading;
  
  console.log('üîç useMercadoPagoPayment - Status isReady:', {
    isReady,
    isInitialized,
    hasAccessToken: !!accessToken,
    hasMpInstance: !!mpInstance,
    notLoading: !mpLoading,
    accessTokenPreview: accessToken ? accessToken.substring(0, 15) + '...' : 'N/A'
  });

  return {
    processPixPayment,
    processCreditCardPayment,
    isReady,
    error: mpError,
    loading: mpLoading,
    retryInitialization
  };
};
