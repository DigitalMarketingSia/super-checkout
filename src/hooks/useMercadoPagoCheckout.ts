
import { useState, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { useGatewayContext } from '@/context/GatewayContext';
import { useToast } from '@/hooks/use-toast';
import { CustomerFormData, CreditCardData } from '@/types/checkout';
import { supabase } from '@/integrations/supabase/client';

interface CheckoutItem {
  id: string;
  title: string;
  quantity: number;
  unit_price: number;
}

interface UseMercadoPagoCheckoutProps {
  items: CheckoutItem[];
  totalAmount: number;
}

// Declarar interface global para o MercadoPago
declare global {
  interface Window {
    MercadoPago: any;
  }
}

export const useMercadoPagoCheckout = ({ items, totalAmount }: UseMercadoPagoCheckoutProps) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [paymentError, setPaymentError] = useState<string | null>(null);
  const { getConnectedGateways } = useGatewayContext();
  const { toast } = useToast();
  const navigate = useNavigate();

  // Initialize MercadoPago SDK
  const initializeMercadoPago = useCallback(async () => {
    console.log('üîÑ Inicializando MercadoPago SDK...');
    
    try {
      const connectedGateways = getConnectedGateways();
      console.log('üîç Gateways conectados:', connectedGateways);
      
      const mpGateway = connectedGateways.find(g => g.type === 'mercado_pago');
      
      if (!mpGateway) {
        console.error('‚ùå Gateway Mercado Pago n√£o encontrado');
        throw new Error('Gateway Mercado Pago n√£o configurado');
      }

      console.log('üîß Gateway encontrado:', mpGateway);
      console.log('üîß Credenciais dispon√≠veis:', Object.keys(mpGateway.credentials));

      // Determinar qual chave p√∫blica usar
      let publicKey;
      
      // Tentar formato novo primeiro (accessToken √∫nico)
      if (mpGateway.credentials.accessToken) {
        const isProduction = mpGateway.credentials.accessToken.includes('APP_USR');
        publicKey = isProduction 
          ? mpGateway.credentials.publicKeyProd 
          : mpGateway.credentials.publicKeySandbox;
      } 
      // Formato antigo (separado por ambiente)
      else {
        const isProduction = mpGateway.environment === 'production';
        publicKey = isProduction 
          ? mpGateway.credentials.publicKeyProd 
          : mpGateway.credentials.publicKeySandbox;
      }

      // Fallback para formato legacy
      if (!publicKey) {
        publicKey = mpGateway.credentials.publicKey;
      }

      console.log('üîë Chave p√∫blica selecionada:', publicKey ? publicKey.substring(0, 20) + '...' : 'N√ÉO ENCONTRADA');

      if (!publicKey) {
        console.error('‚ùå Chave p√∫blica n√£o encontrada nas credenciais');
        throw new Error('Chave p√∫blica do Mercado Pago n√£o configurada');
      }

      // Carregar SDK se ainda n√£o foi carregado
      if (!window.MercadoPago) {
        console.log('üì¶ Carregando SDK do MercadoPago...');
        
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://sdk.mercadopago.com/js/v2';
          script.onload = () => {
            console.log('‚úÖ SDK MercadoPago carregado');
            
            try {
              console.log('üîß Inicializando MercadoPago com chave:', publicKey.substring(0, 20) + '...');
              const mp = new window.MercadoPago(publicKey, {
                locale: 'pt-BR'
              });
              
              console.log('‚úÖ MercadoPago inicializado com sucesso');
              console.log('üîß Objeto MP criado:', typeof mp);
              console.log('üîß M√©todos dispon√≠veis:', Object.getOwnPropertyNames(mp));
              
              resolve(mp);
            } catch (initError) {
              console.error('‚ùå Erro ao inicializar MercadoPago ap√≥s carregamento:', initError);
              reject(initError);
            }
          };
          script.onerror = (error) => {
            console.error('‚ùå Erro ao carregar SDK:', error);
            reject(new Error('Erro ao carregar SDK do MercadoPago'));
          };
          document.head.appendChild(script);
        });
      } else {
        console.log('‚ôªÔ∏è SDK j√° carregado, criando nova inst√¢ncia...');
        
        try {
          console.log('üîß Inicializando MercadoPago com chave:', publicKey.substring(0, 20) + '...');
          const mp = new window.MercadoPago(publicKey, {
            locale: 'pt-BR'
          });
          
          console.log('‚úÖ MercadoPago reinicializado');
          console.log('üîß Objeto MP criado:', typeof mp);
          console.log('üîß M√©todos dispon√≠veis:', Object.getOwnPropertyNames(mp));
          return mp;
        } catch (error) {
          console.error('‚ùå Erro ao reinicializar MercadoPago:', error);
          throw error;
        }
      }
    } catch (error) {
      console.error('‚ùå Erro cr√≠tico na inicializa√ß√£o:', error);
      throw error;
    }
  }, [getConnectedGateways]);

  const createPixPayment = useCallback(async (customerData: CustomerFormData) => {
    setIsProcessing(true);
    setPaymentError(null);

    try {
      console.log('üü¢ Criando pagamento PIX...');
      
      const response = await supabase.functions.invoke('processar-pagamento', {
        body: {
          customerData,
          items,
          totalAmount,
          paymentMethod: 'pix'
        }
      });

      if (response.error) {
        console.error('‚ùå Erro na Edge Function PIX:', response.error);
        throw new Error(response.error.message || 'Erro ao processar PIX');
      }

      const { data } = response;
      
      if (data.success) {
        console.log('‚úÖ PIX criado com sucesso');
        navigate(data.redirectUrl, {
          state: {
            pixData: data.payment,
            orderData: { items, totalAmount }
          }
        });
      } else {
        throw new Error(data.error || 'Erro ao processar pagamento');
      }

    } catch (error) {
      console.error('‚ùå Erro PIX:', error);
      setPaymentError(error instanceof Error ? error.message : 'Erro ao processar PIX');
      toast({
        title: "Erro no Pagamento",
        description: error instanceof Error ? error.message : 'Erro ao processar PIX',
        variant: "destructive"
      });
    } finally {
      setIsProcessing(false);
    }
  }, [items, totalAmount, navigate, toast]);

  const createCreditCardPayment = useCallback(async (
    customerData: CustomerFormData,
    creditCardData: CreditCardData,
    installments: number = 1
  ) => {
    setIsProcessing(true);
    setPaymentError(null);

    try {
      console.log('üí≥ Iniciando pagamento com cart√£o...');
      console.log('üìã Dados do cart√£o (mascarados):', {
        numero: creditCardData.numero.substring(0, 4) + '****',
        nome: creditCardData.nome,
        validade: creditCardData.validade
      });

      // Initialize MercadoPago SDK
      console.log('üîÑ Inicializando SDK...');
      const mp = await initializeMercadoPago();
      
      if (!mp) {
        throw new Error('N√£o foi poss√≠vel inicializar o MercadoPago SDK');
      }

      console.log('‚úÖ SDK inicializado, criando token do cart√£o...');

      // Verificar se o m√©todo createCardToken existe
      if (typeof mp.createCardToken !== 'function') {
        console.error('‚ùå M√©todo createCardToken n√£o dispon√≠vel no objeto MP');
        console.log('üîß M√©todos dispon√≠veis no MP:', Object.getOwnPropertyNames(mp));
        throw new Error('SDK do MercadoPago n√£o foi carregado corretamente');
      }

      // Create card token usando a nova API
      const cardTokenData = {
        cardNumber: creditCardData.numero.replace(/\s/g, ''),
        cardholderName: creditCardData.nome,
        cardExpirationMonth: creditCardData.validade.split('/')[0],
        cardExpirationYear: `20${creditCardData.validade.split('/')[1]}`,
        securityCode: creditCardData.cvv,
        identificationType: 'CPF',
        identificationNumber: creditCardData.cpf.replace(/\D/g, '')
      };

      console.log('üîß Dados para criar token:', {
        ...cardTokenData,
        cardNumber: cardTokenData.cardNumber.substring(0, 4) + '****',
        securityCode: '***',
        identificationNumber: cardTokenData.identificationNumber.substring(0, 3) + '****'
      });

      const cardToken = await mp.createCardToken(cardTokenData);

      console.log('üîß Resposta do token:', cardToken);

      if (cardToken.error) {
        console.error('‚ùå Erro ao criar token:', cardToken.error);
        throw new Error('Dados do cart√£o inv√°lidos: ' + cardToken.error.message);
      }

      if (!cardToken.id) {
        console.error('‚ùå Token n√£o retornado');
        throw new Error('N√£o foi poss√≠vel processar os dados do cart√£o');
      }

      console.log('‚úÖ Token criado:', cardToken.id);

      // Process payment with token
      console.log('üîÑ Enviando para Edge Function...');
      const response = await supabase.functions.invoke('processar-pagamento', {
        body: {
          token: cardToken.id,
          customerData,
          items,
          totalAmount,
          paymentMethod: 'credit_card',
          installments
        }
      });

      console.log('üì• Resposta da Edge Function:', response);

      if (response.error) {
        console.error('‚ùå Erro na Edge Function:', response.error);
        throw new Error(response.error.message || 'Erro ao processar cart√£o');
      }

      const { data } = response;
      
      if (data.success) {
        console.log('‚úÖ Pagamento processado com sucesso');
        navigate(data.redirectUrl);
        
        toast({
          title: "‚úÖ Pagamento Aprovado",
          description: "Seu pagamento foi processado com sucesso!"
        });
      } else {
        console.error('‚ùå Pagamento recusado:', data.error);
        throw new Error(data.error || 'Pagamento recusado');
      }

    } catch (error) {
      console.error('‚ùå Erro Cart√£o:', error);
      const errorMessage = error instanceof Error ? error.message : 'Erro ao processar cart√£o';
      setPaymentError(errorMessage);
      toast({
        title: "Erro no Pagamento",
        description: errorMessage,
        variant: "destructive"
      });
    } finally {
      setIsProcessing(false);
    }
  }, [items, totalAmount, initializeMercadoPago, navigate, toast]);

  const clearPaymentError = useCallback(() => {
    setPaymentError(null);
  }, []);

  return {
    isProcessing,
    paymentError,
    createPixPayment,
    createCreditCardPayment,
    clearPaymentError,
    initializeMercadoPago
  };
};
